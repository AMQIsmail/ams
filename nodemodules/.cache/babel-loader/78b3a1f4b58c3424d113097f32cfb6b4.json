{"ast":null,"code":"import { getApp, _getProvider, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Type constant for Firebase Analytics.\r\n */\n\nconst ANALYTICS_TYPE = 'analytics'; // Key to attach FID to in gtag params.\n\nconst GA_FID_KEY = 'firebase_id';\nconst ORIGIN_KEY = 'origin';\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst logger = new Logger('@firebase/analytics');\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\n\nfunction promiseAllSettled(promises) {\n  return Promise.all(promises.map(promise => promise.catch(e => e)));\n}\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\n\n\nfunction insertScriptTag(dataLayerName, measurementId) {\n  const script = document.createElement('script'); // We are not providing an analyticsId in the URL because it would trigger a `page_view`\n  // without fid. We will initialize ga-id using gtag (config) command together with fid.\n\n  script.src = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\n  script.async = true;\n  document.head.appendChild(script);\n}\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\n\n\nfunction getOrCreateDataLayer(dataLayerName) {\n  // Check for existing dataLayer and create if needed.\n  let dataLayer = [];\n\n  if (Array.isArray(window[dataLayerName])) {\n    dataLayer = window[dataLayerName];\n  } else {\n    window[dataLayerName] = dataLayer;\n  }\n\n  return dataLayer;\n}\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\n\n\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\n  // If config is already fetched, we know the appId and can use it to look up what FID promise we\n  /// are waiting for, and wait only on that one.\n  const correspondingAppId = measurementIdToAppId[measurementId];\n\n  try {\n    if (correspondingAppId) {\n      await initializationPromisesMap[correspondingAppId];\n    } else {\n      // If config is not fetched yet, wait for all configs (we don't know which one we need) and\n      // find the appId (if any) corresponding to this measurementId. If there is one, wait on\n      // that appId's initialization promise. If there is none, promise resolves and gtag\n      // call goes through.\n      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n      const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\n\n      if (foundConfig) {\n        await initializationPromisesMap[foundConfig.appId];\n      }\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n\n  gtagCore(\"config\"\n  /* CONFIG */\n  , measurementId, gtagParams);\n}\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\n\n\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\n  try {\n    let initializationPromisesToWaitFor = []; // If there's a 'send_to' param, check if any ID specified matches\n    // an initializeIds() promise we are waiting for.\n\n    if (gtagParams && gtagParams['send_to']) {\n      let gaSendToList = gtagParams['send_to']; // Make it an array if is isn't, so it can be dealt with the same way.\n\n      if (!Array.isArray(gaSendToList)) {\n        gaSendToList = [gaSendToList];\n      } // Checking 'send_to' fields requires having all measurement ID results back from\n      // the dynamic config fetch.\n\n\n      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n\n      for (const sendToId of gaSendToList) {\n        // Any fetched dynamic measurement ID that matches this 'send_to' ID\n        const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\n        const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\n\n        if (initializationPromise) {\n          initializationPromisesToWaitFor.push(initializationPromise);\n        } else {\n          // Found an item in 'send_to' that is not associated\n          // directly with an FID, possibly a group.  Empty this array,\n          // exit the loop early, and let it get populated below.\n          initializationPromisesToWaitFor = [];\n          break;\n        }\n      }\n    } // This will be unpopulated if there was no 'send_to' field , or\n    // if not all entries in the 'send_to' field could be mapped to\n    // a FID. In these cases, wait on all pending initialization promises.\n\n\n    if (initializationPromisesToWaitFor.length === 0) {\n      initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\n    } // Run core gtag function with args after all relevant initialization\n    // promises have been resolved.\n\n\n    await Promise.all(initializationPromisesToWaitFor); // Workaround for http://b/141370449 - third argument cannot be undefined.\n\n    gtagCore(\"event\"\n    /* EVENT */\n    , measurementId, gtagParams || {});\n  } catch (e) {\n    logger.error(e);\n  }\n}\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\n\n\nfunction wrapGtag(gtagCore,\n/**\r\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\ninitializationPromisesMap,\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\ndynamicConfigPromisesList,\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\nmeasurementIdToAppId) {\n  /**\r\n   * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n   * @param command Gtag command type.\r\n   * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n   * @param gtagParams Params if event is EVENT/CONFIG.\r\n   */\n  async function gtagWrapper(command, idOrNameOrParams, gtagParams) {\n    try {\n      // If event, check that relevant initialization promises have completed.\n      if (command === \"event\"\n      /* EVENT */\n      ) {\n        // If EVENT, second arg must be measurementId.\n        await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, idOrNameOrParams, gtagParams);\n      } else if (command === \"config\"\n      /* CONFIG */\n      ) {\n        // If CONFIG, second arg must be measurementId.\n        await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, idOrNameOrParams, gtagParams);\n      } else if (command === \"consent\"\n      /* CONSENT */\n      ) {\n        // If CONFIG, second arg must be measurementId.\n        gtagCore(\"consent\"\n        /* CONSENT */\n        , 'update', gtagParams);\n      } else {\n        // If SET, second arg must be params.\n        gtagCore(\"set\"\n        /* SET */\n        , idOrNameOrParams);\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n\n  return gtagWrapper;\n}\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\n\n\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\n  // Create a basic core gtag function\n  let gtagCore = function () {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    // Must push IArguments object, not an array.\n    window[dataLayerName].push(arguments);\n  }; // Replace it with existing one if found\n\n\n  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === 'function') {\n    // @ts-ignore\n    gtagCore = window[gtagFunctionName];\n  }\n\n  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\n  return {\n    gtagCore,\n    wrappedGtag: window[gtagFunctionName]\n  };\n}\n/**\r\n * Returns first script tag in DOM matching our gtag url pattern.\r\n */\n\n\nfunction findGtagScriptOnPage() {\n  const scriptTags = window.document.getElementsByTagName('script');\n\n  for (const tag of Object.values(scriptTags)) {\n    if (tag.src && tag.src.includes(GTAG_URL)) {\n      return tag;\n    }\n  }\n\n  return null;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst ERRORS = {\n  [\"already-exists\"\n  /* ALREADY_EXISTS */\n  ]: 'A Firebase Analytics instance with the appId {$id} ' + ' already exists. ' + 'Only one Firebase Analytics instance can be created for each appId.',\n  [\"already-initialized\"\n  /* ALREADY_INITIALIZED */\n  ]: 'initializeAnalytics() cannot be called again with different options than those ' + 'it was initially called with. It can be called again with the same options to ' + 'return the existing instance, or getAnalytics() can be used ' + 'to get a reference to the already-intialized instance.',\n  [\"already-initialized-settings\"\n  /* ALREADY_INITIALIZED_SETTINGS */\n  ]: 'Firebase Analytics has already been initialized.' + 'settings() must be called before initializing any Analytics instance' + 'or it will have no effect.',\n  [\"interop-component-reg-failed\"\n  /* INTEROP_COMPONENT_REG_FAILED */\n  ]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\n  [\"invalid-analytics-context\"\n  /* INVALID_ANALYTICS_CONTEXT */\n  ]: 'Firebase Analytics is not supported in this environment. ' + 'Wrap initialization of analytics in analytics.isSupported() ' + 'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [\"indexeddb-unavailable\"\n  /* INDEXEDDB_UNAVAILABLE */\n  ]: 'IndexedDB unavailable or restricted in this environment. ' + 'Wrap initialization of analytics in analytics.isSupported() ' + 'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [\"fetch-throttle\"\n  /* FETCH_THROTTLE */\n  ]: 'The config fetch request timed out while in an exponential backoff state.' + ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n  [\"config-fetch-failed\"\n  /* CONFIG_FETCH_FAILED */\n  ]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\n  [\"no-api-key\"\n  /* NO_API_KEY */\n  ]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + 'contain a valid API key.',\n  [\"no-app-id\"\n  /* NO_APP_ID */\n  ]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + 'contain a valid app ID.'\n};\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\n\nconst LONG_RETRY_FACTOR = 30;\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\n\nconst BASE_INTERVAL_MILLIS = 1000;\n/**\r\n * Stubbable retry data storage class.\r\n */\n\nclass RetryData {\n  constructor() {\n    let throttleMetadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let intervalMillis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BASE_INTERVAL_MILLIS;\n    this.throttleMetadata = throttleMetadata;\n    this.intervalMillis = intervalMillis;\n  }\n\n  getThrottleMetadata(appId) {\n    return this.throttleMetadata[appId];\n  }\n\n  setThrottleMetadata(appId, metadata) {\n    this.throttleMetadata[appId] = metadata;\n  }\n\n  deleteThrottleMetadata(appId) {\n    delete this.throttleMetadata[appId];\n  }\n\n}\n\nconst defaultRetryData = new RetryData();\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\n\nfunction getHeaders(apiKey) {\n  return new Headers({\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\n\n\nasync function fetchDynamicConfig(appFields) {\n  var _a;\n\n  const {\n    appId,\n    apiKey\n  } = appFields;\n  const request = {\n    method: 'GET',\n    headers: getHeaders(apiKey)\n  };\n  const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\n  const response = await fetch(appUrl, request);\n\n  if (response.status !== 200 && response.status !== 304) {\n    let errorMessage = '';\n\n    try {\n      // Try to get any error message text from server response.\n      const jsonResponse = await response.json();\n\n      if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\n        errorMessage = jsonResponse.error.message;\n      }\n    } catch (_ignored) {}\n\n    throw ERROR_FACTORY.create(\"config-fetch-failed\"\n    /* CONFIG_FETCH_FAILED */\n    , {\n      httpStatus: response.status,\n      responseMessage: errorMessage\n    });\n  }\n\n  return response.json();\n}\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\n\n\nasync function fetchDynamicConfigWithRetry(app) {\n  let retryData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRetryData;\n  let timeoutMillis = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    appId,\n    apiKey,\n    measurementId\n  } = app.options;\n\n  if (!appId) {\n    throw ERROR_FACTORY.create(\"no-app-id\"\n    /* NO_APP_ID */\n    );\n  }\n\n  if (!apiKey) {\n    if (measurementId) {\n      return {\n        measurementId,\n        appId\n      };\n    }\n\n    throw ERROR_FACTORY.create(\"no-api-key\"\n    /* NO_API_KEY */\n    );\n  }\n\n  const throttleMetadata = retryData.getThrottleMetadata(appId) || {\n    backoffCount: 0,\n    throttleEndTimeMillis: Date.now()\n  };\n  const signal = new AnalyticsAbortSignal();\n  setTimeout(async () => {\n    // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n    signal.abort();\n  }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\n  return attemptFetchDynamicConfigWithRetry({\n    appId,\n    apiKey,\n    measurementId\n  }, throttleMetadata, signal, retryData);\n}\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\n\n\nasync function attemptFetchDynamicConfigWithRetry(appFields, _ref, signal) {\n  let {\n    throttleEndTimeMillis,\n    backoffCount\n  } = _ref;\n  let retryData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultRetryData;\n\n  var _a, _b;\n\n  const {\n    appId,\n    measurementId\n  } = appFields; // Starts with a (potentially zero) timeout to support resumption from stored state.\n  // Ensures the throttle end time is honored if the last attempt timed out.\n  // Note the SDK will never make a request if the fetch timeout expires at this point.\n\n  try {\n    await setAbortableTimeout(signal, throttleEndTimeMillis);\n  } catch (e) {\n    if (measurementId) {\n      logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` + ` Falling back to the measurement ID ${measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config. [${(_a = e) === null || _a === void 0 ? void 0 : _a.message}]`);\n      return {\n        appId,\n        measurementId\n      };\n    }\n\n    throw e;\n  }\n\n  try {\n    const response = await fetchDynamicConfig(appFields); // Note the SDK only clears throttle state if response is success or non-retriable.\n\n    retryData.deleteThrottleMetadata(appId);\n    return response;\n  } catch (e) {\n    const error = e;\n\n    if (!isRetriableError(error)) {\n      retryData.deleteThrottleMetadata(appId);\n\n      if (measurementId) {\n        logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` + ` Falling back to the measurement ID ${measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\n        return {\n          appId,\n          measurementId\n        };\n      } else {\n        throw e;\n      }\n    }\n\n    const backoffMillis = Number((_b = error === null || error === void 0 ? void 0 : error.customData) === null || _b === void 0 ? void 0 : _b.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis); // Increments backoff state.\n\n    const throttleMetadata = {\n      throttleEndTimeMillis: Date.now() + backoffMillis,\n      backoffCount: backoffCount + 1\n    }; // Persists state.\n\n    retryData.setThrottleMetadata(appId, throttleMetadata);\n    logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\n    return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\n  }\n}\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\n\n\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\n  return new Promise((resolve, reject) => {\n    // Derives backoff from given end time, normalizing negative numbers to zero.\n    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n    const timeout = setTimeout(resolve, backoffMillis); // Adds listener, rather than sets onabort, because signal is a shared object.\n\n    signal.addEventListener(() => {\n      clearTimeout(timeout); // If the request completes before this timeout, the rejection has no effect.\n\n      reject(ERROR_FACTORY.create(\"fetch-throttle\"\n      /* FETCH_THROTTLE */\n      , {\n        throttleEndTimeMillis\n      }));\n    });\n  });\n}\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\n\n\nfunction isRetriableError(e) {\n  if (!(e instanceof FirebaseError) || !e.customData) {\n    return false;\n  } // Uses string index defined by ErrorData, which FirebaseError implements.\n\n\n  const httpStatus = Number(e.customData['httpStatus']);\n  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;\n}\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\n\n\nclass AnalyticsAbortSignal {\n  constructor() {\n    this.listeners = [];\n  }\n\n  addEventListener(listener) {\n    this.listeners.push(listener);\n  }\n\n  abort() {\n    this.listeners.forEach(listener => listener());\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\n\n\nlet defaultEventParametersForInit;\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\n\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\n  if (options && options.global) {\n    gtagFunction(\"event\"\n    /* EVENT */\n    , eventName, eventParams);\n    return;\n  } else {\n    const measurementId = await initializationPromise;\n    const params = Object.assign(Object.assign({}, eventParams), {\n      'send_to': measurementId\n    });\n    gtagFunction(\"event\"\n    /* EVENT */\n    , eventName, params);\n  }\n}\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\n\n\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\n  if (options && options.global) {\n    gtagFunction(\"set\"\n    /* SET */\n    , {\n      'screen_name': screenName\n    });\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(\"config\"\n    /* CONFIG */\n    , measurementId, {\n      update: true,\n      'screen_name': screenName\n    });\n  }\n}\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\n\n\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\n  if (options && options.global) {\n    gtagFunction(\"set\"\n    /* SET */\n    , {\n      'user_id': id\n    });\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(\"config\"\n    /* CONFIG */\n    , measurementId, {\n      update: true,\n      'user_id': id\n    });\n  }\n}\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\n\n\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\n  if (options && options.global) {\n    const flatProperties = {};\n\n    for (const key of Object.keys(properties)) {\n      // use dot notation for merge behavior in gtag.js\n      flatProperties[`user_properties.${key}`] = properties[key];\n    }\n\n    gtagFunction(\"set\"\n    /* SET */\n    , flatProperties);\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(\"config\"\n    /* CONFIG */\n    , measurementId, {\n      update: true,\n      'user_properties': properties\n    });\n  }\n}\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\n\n\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\n  const measurementId = await initializationPromise;\n  window[`ga-disable-${measurementId}`] = !enabled;\n}\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\n\n\nlet defaultConsentSettingsForInit;\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\n\nfunction _setConsentDefaultForInit(consentSettings) {\n  defaultConsentSettingsForInit = consentSettings;\n}\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\n\n\nfunction _setDefaultEventParametersForInit(customParams) {\n  defaultEventParametersForInit = customParams;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nasync function validateIndexedDB() {\n  var _a;\n\n  if (!isIndexedDBAvailable()) {\n    logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\"\n    /* INDEXEDDB_UNAVAILABLE */\n    , {\n      errorInfo: 'IndexedDB is not available in this environment.'\n    }).message);\n    return false;\n  } else {\n    try {\n      await validateIndexedDBOpenable();\n    } catch (e) {\n      logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\"\n      /* INDEXEDDB_UNAVAILABLE */\n      , {\n        errorInfo: (_a = e) === null || _a === void 0 ? void 0 : _a.toString()\n      }).message);\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\n\n\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\n  var _a;\n\n  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app); // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n\n  dynamicConfigPromise.then(config => {\n    measurementIdToAppId[config.measurementId] = config.appId;\n\n    if (app.options.measurementId && config.measurementId !== app.options.measurementId) {\n      logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` + ` does not match the measurement ID fetched from the server (${config.measurementId}).` + ` To ensure analytics events are always sent to the correct Analytics property,` + ` update the` + ` measurement ID field in the local config or remove it from the local config.`);\n    }\n  }).catch(e => logger.error(e)); // Add to list to track state of all dynamic config promises.\n\n  dynamicConfigPromisesList.push(dynamicConfigPromise);\n  const fidPromise = validateIndexedDB().then(envIsValid => {\n    if (envIsValid) {\n      return installations.getId();\n    } else {\n      return undefined;\n    }\n  });\n  const [dynamicConfig, fid] = await Promise.all([dynamicConfigPromise, fidPromise]); // Detect if user has already put the gtag <script> tag on this page.\n\n  if (!findGtagScriptOnPage()) {\n    insertScriptTag(dataLayerName, dynamicConfig.measurementId);\n  } // Detects if there are consent settings that need to be configured.\n\n\n  if (defaultConsentSettingsForInit) {\n    gtagCore(\"consent\"\n    /* CONSENT */\n    , 'default', defaultConsentSettingsForInit);\n\n    _setConsentDefaultForInit(undefined);\n  } // This command initializes gtag.js and only needs to be called once for the entire web app,\n  // but since it is idempotent, we can call it multiple times.\n  // We keep it together with other initialization logic for better code structure.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  gtagCore('js', new Date()); // User config added first. We don't want users to accidentally overwrite\n  // base Firebase config properties.\n\n  const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {}; // guard against developers accidentally setting properties with prefix `firebase_`\n\n  configProperties[ORIGIN_KEY] = 'firebase';\n  configProperties.update = true;\n\n  if (fid != null) {\n    configProperties[GA_FID_KEY] = fid;\n  } // It should be the first config command called on this GA-ID\n  // Initialize this GA-ID and set FID on it using the gtag config API.\n  // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\n  // `configProperties`.\n\n\n  gtagCore(\"config\"\n  /* CONFIG */\n  , dynamicConfig.measurementId, configProperties); // Detects if there is data that will be set on every event logged from the SDK.\n\n  if (defaultEventParametersForInit) {\n    gtagCore(\"set\"\n    /* SET */\n    , defaultEventParametersForInit);\n\n    _setDefaultEventParametersForInit(undefined);\n  }\n\n  return dynamicConfig.measurementId;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Analytics Service class.\r\n */\n\n\nclass AnalyticsService {\n  constructor(app) {\n    this.app = app;\n  }\n\n  _delete() {\n    delete initializationPromisesMap[this.app.options.appId];\n    return Promise.resolve();\n  }\n\n}\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\n\n\nlet initializationPromisesMap = {};\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\n\nlet dynamicConfigPromisesList = [];\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\n\nconst measurementIdToAppId = {};\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\n\nlet dataLayerName = 'dataLayer';\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\n\nlet gtagName = 'gtag';\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\n\nlet gtagCoreFunction;\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\n\nlet wrappedGtagFunction;\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\n\nlet globalInitDone = false;\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\n\nfunction settings(options) {\n  if (globalInitDone) {\n    throw ERROR_FACTORY.create(\"already-initialized\"\n    /* ALREADY_INITIALIZED */\n    );\n  }\n\n  if (options.dataLayerName) {\n    dataLayerName = options.dataLayerName;\n  }\n\n  if (options.gtagName) {\n    gtagName = options.gtagName;\n  }\n}\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\n\n\nfunction warnOnBrowserContextMismatch() {\n  const mismatchedEnvMessages = [];\n\n  if (isBrowserExtension()) {\n    mismatchedEnvMessages.push('This is a browser extension environment.');\n  }\n\n  if (!areCookiesEnabled()) {\n    mismatchedEnvMessages.push('Cookies are not available.');\n  }\n\n  if (mismatchedEnvMessages.length > 0) {\n    const details = mismatchedEnvMessages.map((message, index) => `(${index + 1}) ${message}`).join(' ');\n    const err = ERROR_FACTORY.create(\"invalid-analytics-context\"\n    /* INVALID_ANALYTICS_CONTEXT */\n    , {\n      errorInfo: details\n    });\n    logger.warn(err.message);\n  }\n}\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\n\n\nfunction factory(app, installations, options) {\n  warnOnBrowserContextMismatch();\n  const appId = app.options.appId;\n\n  if (!appId) {\n    throw ERROR_FACTORY.create(\"no-app-id\"\n    /* NO_APP_ID */\n    );\n  }\n\n  if (!app.options.apiKey) {\n    if (app.options.measurementId) {\n      logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` + ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config.`);\n    } else {\n      throw ERROR_FACTORY.create(\"no-api-key\"\n      /* NO_API_KEY */\n      );\n    }\n  }\n\n  if (initializationPromisesMap[appId] != null) {\n    throw ERROR_FACTORY.create(\"already-exists\"\n    /* ALREADY_EXISTS */\n    , {\n      id: appId\n    });\n  }\n\n  if (!globalInitDone) {\n    // Steps here should only be done once per page: creation or wrapping\n    // of dataLayer and global gtag function.\n    getOrCreateDataLayer(dataLayerName);\n    const {\n      wrappedGtag,\n      gtagCore\n    } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\n    wrappedGtagFunction = wrappedGtag;\n    gtagCoreFunction = gtagCore;\n    globalInitDone = true;\n  } // Async but non-blocking.\n  // This map reflects the completion state of all promises for each appId.\n\n\n  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\n  const analyticsInstance = new AnalyticsService(app);\n  return analyticsInstance;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\n\n\nfunction getAnalytics() {\n  let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getApp();\n  app = getModularInstance(app); // Dependencies\n\n  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\n\n  if (analyticsProvider.isInitialized()) {\n    return analyticsProvider.getImmediate();\n  }\n\n  return initializeAnalytics(app);\n}\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\n\n\nfunction initializeAnalytics(app) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // Dependencies\n  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\n\n  if (analyticsProvider.isInitialized()) {\n    const existingInstance = analyticsProvider.getImmediate();\n\n    if (deepEqual(options, analyticsProvider.getOptions())) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\"\n      /* ALREADY_INITIALIZED */\n      );\n    }\n  }\n\n  const analyticsInstance = analyticsProvider.initialize({\n    options\n  });\n  return analyticsInstance;\n}\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\n\n\nasync function isSupported() {\n  if (isBrowserExtension()) {\n    return false;\n  }\n\n  if (!areCookiesEnabled()) {\n    return false;\n  }\n\n  if (!isIndexedDBAvailable()) {\n    return false;\n  }\n\n  try {\n    const isDBOpenable = await validateIndexedDBOpenable();\n    return isDBOpenable;\n  } catch (error) {\n    return false;\n  }\n}\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\n\n\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\n}\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\n\n\nfunction setUserId(analyticsInstance, id, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\n}\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\n\n\nfunction setUserProperties(analyticsInstance, properties, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\n}\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\n\n\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\n}\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\n\n\nfunction setDefaultEventParameters(customParams) {\n  // Check if reference to existing gtag function on window object exists\n  if (wrappedGtagFunction) {\n    wrappedGtagFunction(\"set\"\n    /* SET */\n    , customParams);\n  } else {\n    _setDefaultEventParametersForInit(customParams);\n  }\n}\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\n\n\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\n}\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\n\n\nfunction setConsent(consentSettings) {\n  // Check if reference to existing gtag function on window object exists\n  if (wrappedGtagFunction) {\n    wrappedGtagFunction(\"consent\"\n    /* CONSENT */\n    , 'update', consentSettings);\n  } else {\n    _setConsentDefaultForInit(consentSettings);\n  }\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.8.0\";\n/**\r\n * Firebase Analytics\r\n *\r\n * @packageDocumentation\r\n */\n\nfunction registerAnalytics() {\n  _registerComponent(new Component(ANALYTICS_TYPE, (container, _ref2) => {\n    let {\n      options: analyticsOptions\n    } = _ref2;\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const installations = container.getProvider('installations-internal').getImmediate();\n    return factory(app, installations, analyticsOptions);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  ));\n\n  _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\"\n  /* PRIVATE */\n  ));\n\n  registerVersion(name, version); // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n\n  registerVersion(name, version, 'esm2017');\n\n  function internalFactory(container) {\n    try {\n      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n      return {\n        logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\n      };\n    } catch (e) {\n      throw ERROR_FACTORY.create(\"interop-component-reg-failed\"\n      /* INTEROP_COMPONENT_REG_FAILED */\n      , {\n        reason: e\n      });\n    }\n  }\n}\n\nregisterAnalytics();\nexport { getAnalytics, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };","map":{"version":3,"mappings":"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","names":["getApp","_getProvider","_registerComponent","registerVersion","Logger","ErrorFactory","calculateBackoffMillis","FirebaseError","isIndexedDBAvailable","validateIndexedDBOpenable","isBrowserExtension","areCookiesEnabled","getModularInstance","deepEqual","Component","ANALYTICS_TYPE","GA_FID_KEY","ORIGIN_KEY","FETCH_TIMEOUT_MILLIS","DYNAMIC_CONFIG_URL","GTAG_URL","logger","promiseAllSettled","promises","Promise","all","map","promise","catch","e","insertScriptTag","dataLayerName","measurementId","script","document","createElement","src","async","head","appendChild","getOrCreateDataLayer","dataLayer","Array","isArray","window","gtagOnConfig","gtagCore","initializationPromisesMap","dynamicConfigPromisesList","measurementIdToAppId","gtagParams","correspondingAppId","dynamicConfigResults","foundConfig","find","config","appId","error","gtagOnEvent","initializationPromisesToWaitFor","gaSendToList","sendToId","initializationPromise","push","length","Object","values","wrapGtag","gtagWrapper","command","idOrNameOrParams","wrapOrCreateGtag","gtagFunctionName","_args","arguments","wrappedGtag","findGtagScriptOnPage","scriptTags","getElementsByTagName","tag","includes","ERRORS","ERROR_FACTORY","LONG_RETRY_FACTOR","BASE_INTERVAL_MILLIS","RetryData","constructor","throttleMetadata","intervalMillis","getThrottleMetadata","setThrottleMetadata","metadata","deleteThrottleMetadata","defaultRetryData","getHeaders","apiKey","Headers","Accept","fetchDynamicConfig","appFields","_a","request","method","headers","appUrl","replace","response","fetch","status","errorMessage","jsonResponse","json","message","_ignored","create","httpStatus","responseMessage","fetchDynamicConfigWithRetry","app","retryData","timeoutMillis","options","backoffCount","throttleEndTimeMillis","Date","now","signal","AnalyticsAbortSignal","setTimeout","abort","undefined","attemptFetchDynamicConfigWithRetry","_b","setAbortableTimeout","warn","isRetriableError","backoffMillis","Number","customData","debug","resolve","reject","Math","max","timeout","addEventListener","clearTimeout","listeners","listener","forEach","defaultEventParametersForInit","logEvent$1","gtagFunction","eventName","eventParams","global","params","assign","setCurrentScreen$1","screenName","update","setUserId$1","id","setUserProperties$1","properties","flatProperties","key","keys","setAnalyticsCollectionEnabled$1","enabled","defaultConsentSettingsForInit","_setConsentDefaultForInit","consentSettings","_setDefaultEventParametersForInit","customParams","validateIndexedDB","errorInfo","toString","_initializeAnalytics","installations","dynamicConfigPromise","then","fidPromise","envIsValid","getId","dynamicConfig","fid","configProperties","AnalyticsService","_delete","gtagName","gtagCoreFunction","wrappedGtagFunction","globalInitDone","settings","warnOnBrowserContextMismatch","mismatchedEnvMessages","details","index","join","err","factory","analyticsInstance","getAnalytics","analyticsProvider","isInitialized","getImmediate","initializeAnalytics","existingInstance","getOptions","initialize","isSupported","isDBOpenable","setCurrentScreen","setUserId","setUserProperties","setAnalyticsCollectionEnabled","setDefaultEventParameters","logEvent","setConsent","name","version","registerAnalytics","container","analyticsOptions","getProvider","internalFactory","analytics","reason"],"sources":["C:/Users/Ismail Saheb/Desktop/AMQ/frontant/react/node_modules/@firebase/analytics/dist/esm/index.esm2017.js"],"sourcesContent":["import { getApp, _getProvider, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    script.src = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, idOrNameOrParams, gtagParams) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* EVENT */) {\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, idOrNameOrParams, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* CONFIG */) {\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, idOrNameOrParams, gtagParams);\r\n            }\r\n            else if (command === \"consent\" /* CONSENT */) {\r\n                // If CONFIG, second arg must be measurementId.\r\n                gtagCore(\"consent\" /* CONSENT */, 'update', gtagParams);\r\n            }\r\n            else {\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* SET */, idOrNameOrParams);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns first script tag in DOM matching our gtag url pattern.\r\n */\r\nfunction findGtagScriptOnPage() {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src && tag.src.includes(GTAG_URL)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-intialized instance.',\r\n    [\"already-initialized-settings\" /* ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    var _a, _b;\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${(_a = e) === null || _a === void 0 ? void 0 : _a.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        const error = e;\r\n        if (!isRetriableError(error)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number((_b = error === null || error === void 0 ? void 0 : error.customData) === null || _b === void 0 ? void 0 : _b.httpStatus) === 503\r\n            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\r\nlet defaultEventParametersForInit;\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\r\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\r\nlet defaultConsentSettingsForInit;\r\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction _setConsentDefaultForInit(consentSettings) {\r\n    defaultConsentSettingsForInit = consentSettings;\r\n}\r\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\r\nfunction _setDefaultEventParametersForInit(customParams) {\r\n    defaultEventParametersForInit = customParams;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    var _a;\r\n    if (!isIndexedDBAvailable()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await validateIndexedDBOpenable();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: (_a = e) === null || _a === void 0 ? void 0 : _a.toString()\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page.\r\n    if (!findGtagScriptOnPage()) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // Detects if there are consent settings that need to be configured.\r\n    if (defaultConsentSettingsForInit) {\r\n        gtagCore(\"consent\" /* CONSENT */, 'default', defaultConsentSettingsForInit);\r\n        _setConsentDefaultForInit(undefined);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    // Detects if there is data that will be set on every event logged from the SDK.\r\n    if (defaultEventParametersForInit) {\r\n        gtagCore(\"set\" /* SET */, defaultEventParametersForInit);\r\n        _setDefaultEventParametersForInit(undefined);\r\n    }\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if (isBrowserExtension()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = getApp()) {\r\n    app = getModularInstance(app);\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if (deepEqual(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if (isBrowserExtension()) {\r\n        return false;\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        return false;\r\n    }\r\n    if (!isIndexedDBAvailable()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await validateIndexedDBOpenable();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\r\nfunction setDefaultEventParameters(customParams) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"set\" /* SET */, customParams);\r\n    }\r\n    else {\r\n        _setDefaultEventParametersForInit(customParams);\r\n    }\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction setConsent(consentSettings) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"consent\" /* CONSENT */, 'update', consentSettings);\r\n    }\r\n    else {\r\n        _setConsentDefaultForInit(consentSettings);\r\n    }\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.8.0\";\n\n/**\r\n * Firebase Analytics\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* PUBLIC */));\r\n    _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\" /* PRIVATE */));\r\n    registerVersion(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\nexport { getAnalytics, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };\n"]},"metadata":{},"sourceType":"module"}